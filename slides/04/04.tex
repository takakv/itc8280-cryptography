\graphicspath{ {../../images/} }
\usetikzlibrary{external}

% Needed for setting font size for mono blocks
\usepackage{fancyvrb}

% Needed for argon2id hash colours
\usepackage[dvipsnames]{xcolor}

% Needed for argon2id hash to fit
\setmonofont{cmuntt}

\title{ITC8280 Fundamentals of Cryptography}
\subtitle{Hash functions \& KDFs}
\date{\today}
\author{Taaniel Kraavi}
\institute%
{%
  \textit{School of Information Technologies}\\
  \textit{Tallinn University of Technology}
}

\begin{document}
\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Hash functions}
  \pause
  A map from arbitrary sized data to fixed-size values.
  \begin{itemize}[<+(1)->]
    \item $h:\{0,1\}^* \to \{0,1\}^n$
    \item Extendable-output functions (XOF): arbitrary-length output
    \item Values are called \emph{hashes} or \emph{digests}
    \item Deterministic
  \end{itemize}

  \vspace*{1em}

  \pause
  A good hash function:
  \begin{itemize}[<+(1)->]
    \item efficient to compute
    \item outputs are (close to) uniformly distributed
    \item low risk of collisions
  \end{itemize}
\end{frame}

\begin{frame}{Pigeonhole principle}
  \pause
  If $n$ items are put into $m$ containers, with $n > m$, then at least one container must contain more than one item.

  \vspace*{1em}

  \pause
  \begin{center}
    \includegraphics[height=150px]{pigeonhole}
  \end{center}
\end{frame}

\begin{frame}{Hash collisions}
  By the pigeonhole principle, hashing is susceptible to collisions.
  \begin{itemize}[<+(1)->]
    \item Different inputs have the same hash
    \item $h(x_1) = h(x_2), x_1 \neq x_2$
  \end{itemize}

  \vspace*{1em}

  \pause
  Consequences:
  \begin{itemize}[<+(1)->]
    \item \enquote{General computing}: bad performance (e.g. indexing)
    \item Cryptography: loss of integrity and/or security
  \end{itemize}

  \vspace*{1em}

  \pause
  Not all hash functions provide \enquote{strong} integrity guarantees!
\end{frame}

\begin{frame}{Cryptographic hash functions (CHF)}
  A \emph{cryptographic hash function} must additionally satisfy:
  \begin{itemize}[<+(1)->]
    \item Collision resistance
    \item (First) preimage resistance
    \item Second preimage resistance
  \end{itemize}

  \vspace*{1em}

  \pause
  Good designs typically have:
  \begin{itemize}[<+(1)->]
    \item Uniform output distribution
    \item Avalanching
    \item Non-linearity
  \end{itemize}
\end{frame}

\begin{frame}{Avalanche effect}
  We often model an ideal hash function as a random oracle.
  \begin{itemize}[<+(1)->]
    \item Changing just a single input re-randomises the output
    \item Flip $50\%$ bits (on average)

  \end{itemize}

  \vspace*{1em}

  \pause
  Example:
  \begin{itemize}
    \item {\small\texttt{md5sum(0x80) = 8d39dd7eef115ea6975446ef4082951f}}
    \item {\small\texttt{md5sum(0x81) = cd25041f9f36811b04ab3015805fe816}}
    \pause\item $83/128$ bits changed
  \end{itemize}
\end{frame}

\begin{frame}{Resistance attacks}
  Collision attack:
  \begin{itemize}[<+(1)->]
    \item Find any two distinct inputs with the same hashes
    \item Find any $x, y$ with $x \neq y$ s.t. $h(x) = h(y)$
  \end{itemize}

  \pause
  (First) preimage attack:
  \begin{itemize}[<+(1)->]
    \item Given some hash, find an input that produces this hash
    \item Given $y \getsu \{0,1\}^n$, find any $x$ such that $h(x) = y$
  \end{itemize}

  \pause
  Second preimage attack:
  \begin{itemize}[<+(1)->]
    \item Given an input, find another input that produces the same hash
    \item Given $x$, find $y \neq x$ s.t. $h(x) = h(y)$
  \end{itemize}
\end{frame}

\begin{frame}{Security level}
  Let $n$ denote the output length of a CHF in bits.

  \vspace*{1em}

  \pause
  Collision resistance:
  \begin{itemize}[<+(1)->]
    \item $n/2$ against classical adversaries (birthday attack)
    \item $n/3$ against quantum adversaries (BHT algorithm)
  \end{itemize}

  \vspace*{1em}

  \pause
  Preimage resistance (first \& second):
  \begin{itemize}[<+(1)->]
    \item $n$ against classical adversaries
    \item $n/2$ against quantum adversaries
  \end{itemize}
\end{frame}

\begin{frame}{\enquote{Weak} vs \enquote{strong} collision resistance}
  Collision resistance $\implies$ second preimage resistance
  \begin{itemize}[<+(1)->]
    \item If you cannot find any collision, you cannot find a specific one
    \item 2\textsuperscript{nd} PIR is sometimes called \emph{weak} CR
    \item In practice, \emph{strong} CR is expected
  \end{itemize}

  \vspace*{1em}

  \pause
  Collision \& pre-image resistance are not everything
  \begin{itemize}[<+(1)->]
    \item Attacks due to constructions may exist, e.g. length-extension
  \end{itemize}
\end{frame}

\begin{frame}{CHFs and integrity}
  CHFs enable integrity verification:
  \begin{itemize}[<+(1)->]
    \item 2\textsuperscript{nd} PIR: cannot change data without changing the hash
    \item Hash the data and compare it to a provided hash
    \par
    \begin{itemize}
      \item If the hashes are equal, data is (likely) unchanged
    \end{itemize}
    \item Danger: an attacker may replace the data and the hash
  \end{itemize}

  \vspace*{1em}

  \pause
  CHFs have many more uses, some of which we will see later.
\end{frame}

\begin{frame}{Similar hashes}
  \pause
  How closely do you check your hashes?
  \begin{center}
    \includegraphics[width=\textwidth]{hashsimil}
  \end{center}
  \vfill
  {\scriptsize\url{https://www.da.vidbuchanan.co.uk/blog/colliding-secure-hashes.html}}
\end{frame}

\begin{frame}[fragile]{Drunken bishops}
  \begin{columns}[onlytextwidth]
    \begin{column}{0.6\textwidth}
      \pause
      Drunken bishops algorithm:
      \begin{itemize}[<+(1)->]
        \item OpenSSH fingerprint visualisation algorithm
        \item ASCII random art
        \item More robust (visually) than hex comparison
      \end{itemize}
    \end{column}
    \begin{column}{0.3\textwidth}
      \begin{Verbatim}[fontsize=\scriptsize]
+--[ED25519 256]--+
|             ..  |
|           .  +. |
|          + .o .o|
|         = =.. .o|
|        S =.+.=..|
|       o O E.+...|
|      . . B.O  ..|
|       .oo.Oo= ..|
|      .. o*=+oo  |
+----[SHA256]-----+
      \end{Verbatim}
    \end{column}
  \end{columns}

  \vfill

  \pause
  For critical applications, always check hashes programmatically!
\end{frame}

\begin{frame}{What CHFs are not}
  CHFs are not suitable for encryption:
  \begin{itemize}[<+(1)->]
    \item hashes cannot be \enquote{decrypted}
    \item there is no secret key
    \item keyed hash functions: MACs, not encryption
  \end{itemize}
\end{frame}

\begin{frame}{What CHFs are not}
  CHFs are not suitable for protecting passwords:
  \begin{itemize}[<+(1)->]
    \item hash functions should be fast to compute
    \item passwords should be slow to brute force
    \item deterministic: enables pre-computation attacks (e.g. rainbow tables)
    \item use a KDF designed for passwords instead
  \end{itemize}
\end{frame}

\begin{frame}{What CHFs are not}
  CHFs are not suitable for anonymisation/pseudonymisation:
  \begin{itemize}[<+(1)->]
    \item hashing identifiers does not anonymise them
    \item small input spaces (e.g. EE ID codes) are brute-forceable
    \item you cannot do lookups if you salt the data
  \end{itemize}
\end{frame}

\begin{frame}{Danger zone}
  Well known hash functions you should not use:
  \begin{itemize}[<+(1)->]
    \item MD5: collisions can be found in seconds
    \item SHA-1:
    \begin{itemize}
      \item collision \href{https://shattered.io}{\textit{demonstrated}}
      \item chosen-prefix collisions are practical
    \end{itemize} 
  \end{itemize}
\end{frame}

\begin{frame}{NIST approved}
  SHA-2 family
    \begin{itemize}[<+(1)->]
      \item SHA-256, SHA-384, SHA-512, SHA-512/256
    \end{itemize}

  \vspace*{1em}

  \pause
  SHA-3 family (Keccak)
    \begin{itemize}[<+(1)->]
      \item SHA3-256, SHA3-384, SHA3-512
      \item SHAKE128, SHAKE256 -- variable length output (XOF)
    \end{itemize}

  \vspace*{1em}

  \pause
  SHA-224, SHA-512/224, SHA3-224 do not provide 128-bit collision security
\end{frame}

\begin{frame}{SHA-2}
  Secure Hash Algorithm 2
  \begin{itemize}
    \item Designed by the NSA
    \item Published in 2001
    \item \href{https://csrc.nist.gov/pubs/fips/180-4/upd1/final}{FIPS 180-4 (Secure Hash Standard)}
    \pause
    \item Merkle-Damg√•rd construction -- vulnerable to length-extension attacks 
  \end{itemize}
\end{frame}

\begin{frame}{SHA-3}
  Secure Hash Algorithm 3
  \begin{itemize}[<+(1)->]
    \item NIST hash function competition (announced 2007)
    \item Need for an alternative construction (to complement SHS)
    \item Won by Keccak in 2012
    \item SHA-3 standardised in 2015 (\href{https://csrc.nist.gov/pubs/fips/202/final}{FIPS 202})
    \pause
    \item Sponge construction -- not vulnerable to length-extension attacks
    \pause
    \item Variable length output variants (SHAKE128 \& SHAKE256)
  \end{itemize}
\end{frame}

\begin{frame}{BLAKE}
  BLAKE's (SHA-3 finalist) successors are good alternatives to SHA-3.

  \vspace*{1em}

  \pause
  BLAKE2b
  \begin{itemize}
    \item Quite popular in blockchain, e.g. ZCash and Polkadot
    \item The full BLAKE2 family includes more functions
  \end{itemize}

  \pause
  BLAKE3
  \begin{itemize}
    \item Very fast in software
    \item Useful built-in features, e.g. XOF, KDF, MAC
  \end{itemize}
\end{frame}

\begin{frame}{Key derivation functions (KDF)}
  1. Derive one or many keys from high-entropy secret input:
  \begin{itemize}[<+(1)->]
    \item obtain keys of a required format
    \item \enquote{Standard} choice: HKDF (\href{https://datatracker.ietf.org/doc/html/rfc5869}{RFC 5869})
    \item e.g. hybrid encryption (cryptographic KDF, \enquote{fast KDF})
  \end{itemize}

  \vspace*{1em}

  \pause
  2. Stretch and/or strengthen keys from the input data:
  \begin{itemize}[<+(1)->]
    \item user-provided passwords: short and low entropy
    \item increased brute-force resistance needed
    \item e.g. symmetric key from a password (password-based KDF, \enquote{slow KDF})
    \item e.g. securely store passwords in \texttt{/etc/shadow}
  \end{itemize}
\end{frame}

\begin{frame}{Right tool for the right task}
  \pause
  \begin{itemize}
    \item Deriving keys from passwords
    \begin{itemize}
      \item key stretching: do not use CHFs!
      \item The final result is secret and used as a key
    \end{itemize}
    \pause
    \item Storing passwords with validation requirements (e.g. social media DB)
    \begin{itemize}
      \item colloquially: password \enquote{hashing}
      \item key stretching: do not use CHFs!
      \item The final result is stored and used for comparison
    \end{itemize}
    \pause
    \item Hybrid cryptosystems
    \begin{itemize}
      \item high-entropy key derivation: use HKDF
      \item The final result is secret and used as a key
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Password hashing pt. 1}
  Introduce randomness with a \emph{salt}:
  \begin{itemize}[<+(1)->]
    \item similar to a nonce/IV: \emph{always} use but \emph{do not re-use}
    \item use \emph{before} hashing to change the output
    \item store the salt alongside the hash, it is \emph{not secret}
    \item prevents direct comparison (e.g. different users, same password)
    \item prevents pre-computation attacks (e.g. rainbow tables) for long-enough salts
  \end{itemize}
\end{frame}

\begin{frame}{Password hashing pt. 2}
  Increase execution time/resources needed:
  \begin{itemize}[<+(1)->]
    \item e.g. iterative hashing: $H(H(H(\dots H(H(\mathit{password}))\dots)))$
    \begin{itemize}
      \item different techniques exist, e.g. memory-hard constructions
      \item no computational shortcuts must be known
    \end{itemize}
    \item slows down brute-force (e.g. dictionary attacks)
    \item different use-cases: different parameters (social media login vs. FDE)
    \item use at least the recommended minimum params (KDF-dependent)
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Salted password validation}
  To validate a provided password:
  \begin{enumerate}[<+(1)->]
    \item look up the salted password with an identifier (e.g. username)
    \item hash the provided password with the stored salt
    \item compare the result with the stored result (in constant time)
    \item accept or reject
  \end{enumerate}

  \vspace*{1em}

  \pause
  Example of a salted hash (argon2id):
  \vspace*{-1em}
  \begin{center}
    \texttt{\$argon2id\$v=19\${\color{Melon}m=19456,t=2,p=1}\${\color{CadetBlue}bXlzYWx0IDop}\${\color{PineGreen}16E7QlHDtnMnvUsXDPtqKA}}\\
    \texttt{%
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ %
    \ {\color{Melon}params}\ \ \ \ \ %
    \ \ \ \ \ {\color{CadetBlue}salt}\ \ \ \ \ %
    \ \ \ \ \ \ {\color{PineGreen}pwd hash}%
    \ \ \ \ \ \ \ }
  \end{center}
\end{frame}

\begin{frame}{Peppering}
  A pepper is a secret used to protect passwords without encryption:
  \begin{itemize}[<+(1)->]
    \item shared among all passwords in a database
    \item secret, and not stored with the password
    \begin{itemize}
      \item store on an HSM or a digital vault
      \item if the DB can be breached, what else can...
    \end{itemize}
    \item trickier to use for questionable benefit
    \begin{itemize}
      \item good salting will protect the passwords
      \item increases the complexity for yourself
      \item lose the pepper = credentials are void
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Peppering}
  Peppering can work for your personal passwords:
  \begin{itemize}[<+(1)->]
    \item use for critical passwords in your password manager
    \item manually enter the prefix/suffix
  \end{itemize}
\end{frame}

\begin{frame}{What to use for password hashing?}
  NIST strikes again:
  \begin{itemize}[<+(1)->]
    \item Password Hashing Competition (2013)
    \item Winner: Argon2
  \end{itemize}

  \vspace*{1em}

  \pause
  OWASP password storage cheat sheet (\href{https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html}{\textit{link}}):
  \begin{enumerate}[<+(1)->]
    \item Use Argon2id whenever possible (not Argon2d or Argon2i)
    \item \texttt{scrypt} if Argon2id is not available
    \item \texttt{bcrypt} for legacy systems
    \item PBKDF2 if FIPS-compliance is needed
  \end{enumerate}

  \pause
  Suggested parameters in \href{https://datatracker.ietf.org/doc/html/rfc9106\#name-parameter-choice}{RFC9106} and the OWASP cheat sheet.
\end{frame}

\end{document}
